<!DOCTYPE html>
<html>
    <body>
        <script>
            /**
             * Demostrate crash of canvas when filling GPU memory buffers and detection of crash
             */

            const canvasItems = [];
			const GPU_MEM_GB = 16; // !!!! SET TO CURRENT AVAILABLE GPU MEMORY in GB !!!!
			const SIZE = 4096;
			const SINGLE_CANVAS_MEM = SIZE * SIZE * 4; // 4 bytes per pixel
			
			const MAX_CANVASES = (GPU_MEM_GB * 1024*1024*1024 / SINGLE_CANVAS_MEM);
			
            function afterCanvasCreation() {
                // add 1 canvas to DOM to force rendering and filling of GPU buffers
                const canvas = canvasItems[0];
                document.body.appendChild(canvas);
                
                console.log("end");

                // async (since it may not crash immediatly) validation that canvas crashed by check expected colored pixel exist
                setTimeout(() => {
                    const data = canvasItems[0].getContext("2d").getImageData(0, 0, 1, 1).data;

                    if(data[0] === parseInt("aa", 16) && data[1] === parseInt("bb", 16) && data[2] === parseInt("cc", 16)) {
                        console.log("all good - no canvas crash");
                    } else {
                        console.warn("canvas crashed!");
                    }
                }, 100);
            }
			
			function createCanvasElements(count) {
				if (canvasItems.length < MAX_CANVASES)
				{
					var count = Math.min(MAX_CANVASES - canvasItems.length, 10);
					for (var i = 0; i < count; i++) {
						// create large canvas
						const canvas = document.createElement("canvas");
						canvas.width = SIZE;
						canvas.height = SIZE;

						const ctx = canvas.getContext("2d");
					
						// draw colored rect so that GPU buffer will fill and we can check if crashed
						ctx.fillStyle = "#aabbcc";
						ctx.fillRect(0, 0, 10, 10);
						//ctx.getImageData(0, 0, 1, 1);
				  
						// keep a reference to the canvas so that it wouldn't be collected
						canvasItems.push(canvas);
					}
					
					console.log("canvas count: ", canvasItems.length, " heapSizeLimit: ", performance.memory.jsHeapSizeLimit, " totalUsed: ", performance.memory.totalJSHeapSize);
					window.requestAnimationFrame(() => {window.setTimeout(createCanvasElements, 0)});
				} else {
					afterCanvasCreation();
				}
			}

            createCanvasElements();

/*
const canvasItems = [];
function fillCanvases() {
	const GPU_MEM_GB = 15; // !!!! SET TO CURRENT AVAILABLE GPU MEMORY in GB !!!!
	const SIZE = 1536;
	const SINGLE_CANVAS_MEM = SIZE * SIZE * 4; // 4 bytes per pixel
	
	const MAX_CANVASES = (GPU_MEM_GB * 1024*1024*1024 / SINGLE_CANVAS_MEM);
	
	for(let i=0; i < MAX_CANVASES; i++) {
		// create large canvas
		const canvas = document.createElement("canvas");
		canvas.width = SIZE;
		canvas.height = SIZE;

		const ctx = canvas.getContext("2d");
	
		// draw colored rect so that GPU buffer will fill and we can check if crashed
		ctx.fillStyle = "#aabbcc";
		ctx.fillRect(0, 0, 10, 10);
  
		// keep a reference to the canvas so that it wouldn't be collected
		canvasItems.push(canvas);
	}
}
*/
        </script>
    </body>
</html>
